# KB Validation System

This directory contains comprehensive validation tools for the KB system:

- Pydantic validation models for all KB templates
- Orchestrator gatekeeper for completion checking
- Event scanning and classification
- Emergency override capabilities

## Quick Usage

### Template Validation:

```bash
cd .claude/resources/validation
python validate.py research_proposal my_proposal.yaml
python validate.py decision_document decision.yaml
```

### Orchestrator Gatekeeper:

```bash
# Check if orchestrator can complete (MANDATORY before completion)
python validate.py --gatekeeper-check

# Scan for KB lifecycle events
python validate.py --scan-events

# Emergency override (exceptional circumstances only)
python validate.py --emergency-override "Production hotfix required"
```

### Direct Gatekeeper Usage:

```bash
# Using the gatekeeper script directly
python gatekeeper.py --check
python gatekeeper.py --scan
python gatekeeper.py --test
```

### Available Template Types:

- `research_request` - GitHub issue research requests
- `research_proposal` - Generated by intake agent
- `research_plan` - Detailed execution plans
- `decision_document` - Decision recommendations
- `implementation_tracking` - Progress tracking
- `roi_analysis` - Return on investment analysis
- `event_definition` - Event specifications
- `session_summary` - Session capture
- `agent_specification` - Agent definitions

## Integration Examples

### Python Script Validation:

```python
from template_models import validate_template_data
import yaml

# Load and validate template data
with open('proposal.yaml') as f:
    data = yaml.safe_load(f)

validated = validate_template_data('research_proposal', data)
print(f"Research ID: {validated['research_id']}")
```

### Claude Code Integration:

```python
# In agent code, validate before processing
try:
    validated_proposal = validate_template_data('research_proposal', proposal_data)
    # Process validated data...
except ValueError as e:
    # Handle validation error...
    return f"Invalid proposal format: {e}"
```

## Validation Rules

### Research ID Format:

- Pattern: `ABC_123` (3 letters, underscore, 3 digits)
- Example: `MEM_001`, `AIO_042`

### Required Fields by Template:

- **Research Proposal**: research_id, title, category, priority, complexity,
  research_question, success_criteria (min 2)
- **Decision Document**: recommendation (min 100 chars), rationale (min 200
  chars), evidence (min 2 items)
- **Implementation Tracking**: completion_percentage (0-100), milestones with
  required keys
- **ROI Analysis**: roi_calculation with total_investment, total_return,
  roi_percentage, payback_period

### Enums and Constraints:

- **Priority**: high, medium, low
- **Category**: AIO, MEM, TLI, ARC, DEV, UXP
- **Complexity**: low, medium, high
- **Status**: pending, in_progress, completed, approved, needs_revision,
  rejected

## Error Handling

Common validation errors and solutions:

### Research ID Format Error:

```
ValueError: Research ID must follow pattern: ABC_123
```

**Solution**: Use 3 uppercase letters, underscore, 3 digits

### Missing Required Fields:

```
ValueError: field required: success_criteria
```

**Solution**: Add missing field to template data

### Minimum Length Violations:

```
ValueError: ensure this value has at least 100 characters
```

**Solution**: Expand content to meet minimum requirements

### Invalid Enum Values:

```
ValueError: value is not a valid enumeration member
```

**Solution**: Use valid enum values (see lists above)

## Template Schema Evolution

When updating templates:

1. Update Pydantic models in `template_models.py`
2. Update template files in `../templates/`
3. Test validation with sample data
4. Update this README with new constraints

This ensures backward compatibility and maintains data quality standards.

## Orchestrator Gatekeeper System

### Critical Requirement from CLAUDE.md

The gatekeeper implements the **MANDATORY** orchestrator completion check:

```python
# CRITICAL EXECUTION RULE #5: NEVER skip the event scanner check
async def orchestrator_completion_check():
    # 1. Run event scanner
    events = await scan_kb_events()
    
    # 2. Check parallelizable events
    if events['parallelizable']:
        raise Exception("Cannot complete - parallel events pending")
    
    # 3. Check sequential events  
    if events['sequential']:
        raise Exception("Cannot complete - sequential events pending")
    
    # 4. Check blocked events
    # 5. Validate all swarms completed
```

### Integration in Orchestrator Code

```python
from gatekeeper import OrchestratorGatekeeper, GatekeeperException

async def orchestrator_workflow():
    """Orchestrator must call gatekeeper before completion"""
    
    # Execute all orchestrator tasks
    await execute_research_swarm()
    await execute_decision_phase()
    await consolidate_results()
    
    # MANDATORY: Check before declaring completion
    gatekeeper = OrchestratorGatekeeper()
    
    try:
        await gatekeeper.orchestrator_completion_check()
        return "âœ… Orchestration completed successfully"
        
    except GatekeeperException as e:
        # Cannot complete - must process pending events
        print(f"ðŸš« Completion blocked: {e.reason}")
        
        # Process events before retry
        if e.events.parallelizable:
            await process_parallel_events(e.events.parallelizable)
        if e.events.sequential:
            await process_sequential_events(e.events.sequential)
        
        # Retry completion check
        await gatekeeper.orchestrator_completion_check()
        return "âœ… Orchestration completed after event processing"
```

### Event Classification

Events are automatically classified as:

- **Parallelizable**: Can process simultaneously
  - `research.requested` â†’ kb-intake-swarm
  - `research.proposed` â†’ kb-planning-swarm
  - `research.active` â†’ kb-research-swarm
  - `implementation.approved` â†’ kb-implementation-swarm

- **Sequential**: Must process in order
  - `decision.ready` â†’ kb-decision-swarm
  - `decision.review` â†’ kb-decision-review-swarm
  - `metrics.review` â†’ kb-roi-swarm

- **Blocked**: Cannot process due to conditions
  - Missing dependencies
  - Timeout violations
  - Resource conflicts
  - Explicit blocking labels

### GitHub Repository Setup

Required labels for event detection:

```yaml
# Stage labels (mutually exclusive)
- stage:research.requested
- stage:research.proposed
- stage:research.active
- stage:decision.ready
- stage:decision.review
- stage:implementation.approved
- stage:implementation.active
- stage:metrics.review

# Category labels
- category:AIO # AI/Orchestration
- category:MEM # Memory/Persistence
- category:TLI # Tools/Integration
- category:ARC # Architecture
- category:DEV # Developer Experience
- category:UXP # User Experience

# Priority labels
- priority:critical
- priority:high
- priority:medium
- priority:low

# Status labels
- status:blocked
- status:needs-revision
- status:ready
- status:in-progress
```

### Environment Setup

```bash
# Required environment variables
export GITHUB_TOKEN="your_personal_access_token"
export GITHUB_REPOSITORY="owner/repo"

# Optional configuration
export KB_CONFIG_PATH=".claude/kb-config.yaml"
export GATEKEEPER_LOG_LEVEL="INFO"
```

### Emergency Override

For exceptional circumstances requiring manual bypass:

```python
gatekeeper = OrchestratorGatekeeper()

# Document the emergency situation
reason = """
Production hotfix required - bypassing pending research cycles
due to critical security vulnerability CVE-2024-XXXX.
Will resume normal KB lifecycle after emergency deployment.
Authorized by: John Doe, CTO
Incident: INC-2024-001
"""

await gatekeeper.emergency_override(reason)
```

Emergency overrides:

- Create audit trails in `override-records/`
- Require documented justification
- Are logged for compliance review
- Should be rare exceptional events

### Files in This Directory

- **`gatekeeper.py`** - Main gatekeeper implementation
- **`gatekeeper-config.yaml`** - Configuration settings
- **`gatekeeper-examples.py`** - Usage examples and tests
- **`GATEKEEPER_README.md`** - Detailed gatekeeper documentation
- **`template_models.py`** - Pydantic validation models
- **`validate.py`** - Unified validation CLI (templates + gatekeeper)
- **`validate_all.py`** - Batch validation runner

### Critical Integration Points

1. **Orchestrator Completion**: Must call `orchestrator_completion_check()`
   before any completion
2. **Agent Communication**: Agents post standardized GitHub comments with
   signatures
3. **Swarm Tracking**: Orchestrator posts swarm start/completion markers
4. **Event Processing**: Events are processed based on classification
5. **Audit Trail**: All gatekeeper actions are logged for compliance
