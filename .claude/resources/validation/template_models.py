# Pydantic Validation Models for KB Templates
from datetime import datetime
from enum import Enum
from typing import Any, Literal

from pydantic import BaseModel, Field, field_validator


class Priority(str, Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class Category(str, Enum):
    AIO = "AIO"  # AI/Automation/Optimization
    MEM = "MEM"  # Memory/Knowledge Management
    TLI = "TLI"  # Tooling/Libraries/Infrastructure
    ARC = "ARC"  # Architecture/System Design
    DEV = "DEV"  # Development/Engineering
    UXP = "UXP"  # User Experience/Product


class Complexity(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


class Status(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    APPROVED = "approved"
    NEEDS_REVISION = "needs_revision"
    REJECTED = "rejected"


# Research Request Validation
class ResearchRequest(BaseModel):
    """Validation for GitHub research request issues"""

    title: str = Field(..., min_length=10, max_length=200)
    problem_statement: str = Field(..., min_length=50)
    business_impact: str = Field(..., min_length=30)
    desired_outcome: str = Field(..., min_length=30)
    background: str | None = None
    constraints: list[str] | None = None
    stakeholders: list[str] | None = None
    timeline: str | None = None
    priority: Priority = Priority.MEDIUM
    category: Category | None = None

    @field_validator("title")
    @classmethod
    def title_must_start_with_research(cls, v):
        if not v.startswith("[RESEARCH]"):
            return f"[RESEARCH] {v}"
        return v


# Research Proposal Validation
class ResearchProposal(BaseModel):
    """Validation for research proposals generated by intake agent"""

    research_id: str = Field(..., pattern=r"^[A-Z]{3}_\d{3}$")
    title: str = Field(..., min_length=10, max_length=200)
    category: Category
    priority: Priority
    complexity: Complexity
    research_question: str = Field(..., min_length=20)
    success_criteria: list[str] = Field(..., min_items=2)
    approach: str = Field(..., min_length=50)
    timeline: str
    resources_needed: list[str]
    risks: list[str]
    alternatives: list[str]
    stakeholders: list[str]
    created_at: datetime
    created_by: str = "intake_agent"

    @field_validator("research_id")
    @classmethod
    def validate_research_id(cls, v):
        if not v.match(r"^[A-Z]{3}_\d{3}$"):
            raise ValueError("Research ID must follow pattern: ABC_123")
        return v


# Research Plan Validation
class ResearchPlan(BaseModel):
    """Validation for detailed research execution plans"""

    research_id: str = Field(..., pattern=r"^[A-Z]{3}_\d{3}$")
    title: str
    methodology: str = Field(..., min_length=100)
    phases: list[dict[str, Any]] = Field(..., min_items=1)
    deliverables: list[str] = Field(..., min_items=1)
    timeline: str
    resources: dict[str, Any]
    quality_gates: list[str]
    risk_mitigation: list[str]
    communication_plan: str
    created_at: datetime
    approved_by: str | None = None

    @field_validator("phases")
    @classmethod
    @classmethod
    def validate_phases(cls, v):
        required_keys = ["name", "description", "duration", "deliverables"]
        for phase in v:
            for key in required_keys:
                if key not in phase:
                    raise ValueError(f"Phase missing required key: {key}")
        return v


# Decision Document Validation
class DecisionDocument(BaseModel):
    """Validation for decision documents"""

    research_id: str = Field(..., pattern=r"^[A-Z]{3}_\d{3}$")
    title: str
    recommendation: str = Field(..., min_length=100)
    rationale: str = Field(..., min_length=200)
    evidence: list[str] = Field(..., min_items=2)
    implementation_plan: dict[str, Any]
    resource_requirements: dict[str, Any]
    risk_assessment: list[dict[str, str]]
    success_metrics: list[str]
    alternatives_considered: list[str]
    stakeholder_impact: dict[str, str]
    timeline: str
    confidence_level: Literal["low", "medium", "high"]
    created_at: datetime
    reviewed_by: list[str] | None = None
    status: Status = Status.PENDING

    @field_validator("risk_assessment")
    @classmethod
    def validate_risks(cls, v):
        required_keys = ["risk", "probability", "impact", "mitigation"]
        for risk in v:
            for key in required_keys:
                if key not in risk:
                    raise ValueError(f"Risk missing required key: {key}")
        return v


# Implementation Tracking Validation
class ImplementationTracking(BaseModel):
    """Validation for implementation tracking documents"""

    research_id: str = Field(..., pattern=r"^[A-Z]{3}_\d{3}$")
    decision_id: str
    title: str
    implementation_status: Status
    milestones: list[dict[str, Any]]
    current_phase: str
    completion_percentage: int = Field(..., ge=0, le=100)
    blockers: list[str]
    resources_used: dict[str, Any]
    timeline_variance: str
    quality_metrics: dict[str, Any]
    stakeholder_feedback: list[str]
    next_actions: list[str]
    last_updated: datetime
    updated_by: str

    @field_validator("milestones")
    @classmethod
    def validate_milestones(cls, v):
        required_keys = ["name", "due_date", "status", "completion_criteria"]
        for milestone in v:
            for key in required_keys:
                if key not in milestone:
                    raise ValueError(f"Milestone missing required key: {key}")
        return v


# ROI Analysis Validation
class ROIAnalysis(BaseModel):
    """Validation for ROI analysis documents"""

    research_id: str = Field(..., pattern=r"^[A-Z]{3}_\d{3}$")
    implementation_id: str
    title: str
    analysis_period: str
    metrics_collected: dict[str, Any]
    baseline_measurements: dict[str, float]
    current_measurements: dict[str, float]
    improvements: dict[str, dict[str, Any]]
    roi_calculation: dict[str, float]
    cost_analysis: dict[str, float]
    benefit_analysis: dict[str, float]
    qualitative_benefits: list[str]
    lessons_learned: list[str]
    recommendations: list[str]
    confidence_level: Literal["low", "medium", "high"]
    next_review_date: datetime
    created_at: datetime
    analyst: str

    @field_validator("roi_calculation")
    @classmethod
    def validate_roi(cls, v):
        required_keys = [
            "total_investment",
            "total_return",
            "roi_percentage",
            "payback_period",
        ]
        for key in required_keys:
            if key not in v:
                raise ValueError(
                    f"ROI calculation missing required key: {key}"
                )
        return v


# Event Definition Validation
class EventDefinition(BaseModel):
    """Validation for event definitions"""

    id: str = Field(..., pattern=r"^\d{3}$")
    name: str = Field(..., pattern=r"^[a-z]+\.[a-z_]+$")
    description: str = Field(..., min_length=20)
    triggers: list[str] = Field(..., min_items=1)
    conditions: list[str]
    actions: list[str] = Field(..., min_items=1)
    agents_involved: list[str]
    swarm_pattern: Literal["parallel", "sequential", "hybrid"]
    timeout: str
    retry_policy: dict[str, Any]
    success_criteria: list[str]
    failure_handling: list[str]
    github_integration: dict[str, Any]
    memory_updates: list[str]

    @field_validator("name")
    @classmethod
    def validate_event_name(cls, v):
        if not v.count(".") >= 1:
            raise ValueError(
                "Event name must contain at least one dot (e.g., research.requested)"
            )
        return v


# Session Summary Validation
class SessionSummary(BaseModel):
    """Validation for session summaries"""

    session_id: str
    start_time: datetime
    end_time: datetime
    duration: str
    participants: list[str]
    research_ids_discussed: list[str]
    decisions_made: list[str]
    actions_taken: list[str]
    insights_generated: list[str]
    blockers_identified: list[str]
    next_steps: list[str]
    memory_items_created: list[str]
    knowledge_graph_updates: list[str]
    follow_up_required: list[str]
    session_type: Literal[
        "research", "decision", "implementation", "review", "planning"
    ]
    quality_score: int = Field(..., ge=1, le=10)

    @field_validator("duration")
    @classmethod
    def validate_duration(cls, v):
        if not v.endswith(("m", "h", "d")):
            raise ValueError(
                "Duration must end with m (minutes), h (hours), or d (days)"
            )
        return v


# Agent Specification Validation
class AgentSpecification(BaseModel):
    """Validation for agent specification files"""

    agent_id: str = Field(..., pattern=r"^[a-z_]+_agent$")
    name: str
    role: str = Field(..., min_length=10)
    responsibilities: list[str] = Field(..., min_items=3)
    capabilities: list[str] = Field(..., min_items=2)
    tools_available: list[str]
    input_formats: list[str]
    output_formats: list[str]
    decision_logic: str = Field(..., min_length=100)
    quality_criteria: list[str]
    escalation_triggers: list[str]
    communication_protocols: list[str]
    timeout: str
    retry_policy: dict[str, Any]
    success_metrics: list[str]

    @field_validator("agent_id")
    @classmethod
    def validate_agent_id(cls, v):
        if not v.endswith("_agent"):
            raise ValueError("Agent ID must end with _agent")
        return v


# Template validation registry
TEMPLATE_VALIDATORS = {
    "research_request": ResearchRequest,
    "research_proposal": ResearchProposal,
    "research_plan": ResearchPlan,
    "decision_document": DecisionDocument,
    "implementation_tracking": ImplementationTracking,
    "roi_analysis": ROIAnalysis,
    "event_definition": EventDefinition,
    "session_summary": SessionSummary,
    "agent_specification": AgentSpecification,
}


def validate_template_data(
    template_type: str, data: dict[str, Any]
) -> dict[str, Any]:
    """Validate template data against appropriate Pydantic model"""
    validator = TEMPLATE_VALIDATORS.get(template_type)
    if not validator:
        raise ValueError(f"Unknown template type: {template_type}")

    try:
        validated = validator(**data)
        return validated.dict()
    except Exception as e:
        raise ValueError(f"Validation failed for {template_type}: {e!s}")
