{# Meta-Prompt Template for Guided Neural-Symbolic Reasoning #}

{% set reasoning_mode = reasoning_mode | default('structured') %}

{# Reasoning Framework Configuration #}
{% set reasoning_components = {
    'structured': {
        'steps': [
            'atomic_decomposition',
            'logical_connection',
            'coherence_verification'
        ],
        'operators': [
            'composition',
            'abstraction',
            'refinement'
        ]
    },
    'analytical': {
        'steps': [
            'pattern_recognition',
            'causal_inference',
            'consistency_check'
        ],
        'operators': [
            'comparison',
            'synthesis',
            'evaluation'
        ]
    },
    'creative': {
        'steps': [
            'conceptual_expansion',
            'analogy_mapping',
            'novel_combination'
        ],
        'operators': [
            'transformation',
            'fusion',
            'extension'
        ]
    }
} %}

{# Core Reasoning Template #}
Given the task: {{ task_description }}

Apply the following neural-symbolic reasoning framework:

1. STRUCTURAL DECOMPOSITION:
   - Parse the problem space into atomic conceptual units
   - Identify fundamental relationships and dependencies
   - Map the conceptual hierarchy using formal logic operators:
     * ∧ (conjunction) for complementary concepts
     * ∨ (disjunction) for alternative pathways
     * → (implication) for causal relationships
     * ∀ (universal quantification) for general principles
     * ∃ (existential quantification) for specific instances

2. REASONING PATHWAY:
   {% for step in reasoning_components[reasoning_mode]['steps'] %}
   - Apply {{ step }}:
     * Define scope and constraints
     * Apply relevant operators
     * Validate intermediate conclusions
   {% endfor %}

3. SYMBOLIC MANIPULATION:
   - For each conceptual transformation:
     * State initial representation
     * Apply transformation rules:
       {% for operator in reasoning_components[reasoning_mode]['operators'] %}
       - {{ operator }}
       {% endfor %}
     * Verify preservation of semantic meaning

4. COHERENCE VERIFICATION:
   - Apply these validation operators:
     * ⊢ (logical entailment) to verify inference steps
     * ≡ (logical equivalence) to confirm meaning preservation
     * ⊥ (contradiction check) to ensure consistency
   - Verify:
     * Local consistency (within each step)
     * Global coherence (across entire solution)
     * Semantic preservation (through transformations)

5. OUTPUT REFINEMENT:
   - Apply quality enhancement operators:
     * Clarity maximization: max(C) where C = clarity_metric
     * Precision optimization: min(∆) where ∆ = ambiguity_measure
     * Coherence strengthening: max(H) where H = semantic_cohesion
   - Ensure:
     * Completeness of reasoning chain
     * Precision of language
     * Appropriate level of detail

Requirements for Neural Processing:
- Maintain activation patterns that support logical consistency
- Preserve semantic relationships through transformations
- Ensure gradient flow through all reasoning steps
- Balance exploration vs exploitation in solution space

Validation Criteria:
1. Logical soundness (L)
2. Semantic coherence (S)
3. Pragmatic relevance (P)
4. Output quality (Q)

Optimization Goal:
maximize(α₁L + α₂S + α₃P + α₄Q)
subject to:
- consistency_constraints
- relevance_threshold
- quality_requirements

{% if task_specific_constraints %}
Additional Task-Specific Constraints:
{{ task_specific_constraints }}
{% endif %}

{# Error Handling and Recovery #}
On detecting reasoning inconsistency:
1. Isolate affected reasoning branch
2. Apply error correction operators
3. Recompute affected segments
4. Verify global consistency

{# Output Format Control #}
Format response to optimize for:
1. Clarity of reasoning steps
2. Explicitness of logical connections
3. Precision of language
4. Appropriate detail level for task context
